/*
 * Copyright (C) 2002-2009 Alexei Drummond and Andrew Rambaut
 *
 * This file is part of BEAST.
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership and licensing.
 *
 * BEAST is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * BEAST is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with BEAST; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301  USA
 */

package dr.app.beauti.options;

import java.text.NumberFormat;
import java.text.ParseException;
import java.util.List;

import dr.app.beauti.enumTypes.FixRateType;
import dr.app.beauti.enumTypes.OperatorType;
import dr.app.beauti.enumTypes.RelativeRatesType;
import dr.util.NumberFormatter;


/**
 * @author Alexei Drummond
 * @author Andrew Rambaut
 * @author Walter Xie
 * @version $Id$
 */
public class PriorOptions extends ModelOptions {

	// Instance variables
    private final BeautiOptions options;
   
    
    double growthRateMaximum = 1E6;
    double birthRateMaximum = 1E6;
    double substitutionRateMaximum = 100;
    double logStdevMaximum = 10;
    double substitutionParameterMaximum = 100;
    double initialRootHeight = 1;
    double initialRate = 1;

    public PriorOptions(BeautiOptions options) {    	
    	this.options = options;
               
        
    }
       
    
    /**
     * return a list of parameters that are required
     *
     * @param params the parameter list
     */
    public void selectParameters(List<Parameter> params) {    	    	


//        if (options.clockModelOptions.getRateOptionClockModel() == FixRateType.FIX_MEAN) {
//            double rate = options.clockModelOptions.getMeanRelativeRate();
//
//            growthRateMaximum = 1E6 * rate;
//            birthRateMaximum = 1E6 * rate;
//
//            if (options.hasData()) {
//                initialRootHeight = meanDistance / rate;
//
//                initialRootHeight = round(initialRootHeight, 2);
//            }
//
//        } else {
//            if (maximumTipHeight > 0) {
//                initialRootHeight = maximumTipHeight * 10.0;
//            }
//
//            initialRate = round((meanDistance * 0.2) / initialRootHeight, 2);
//        }
//
//        double timeScaleMaximum = round(initialRootHeight * 1000.0, 2);
//
//        for (Parameter param : params) {
////            if (dataReset) param.priorEdited = false;
//
//            if (!param.priorEdited) {
//                switch (param.scale) {
//                    case TIME_SCALE:
//                        param.uniformLower = Math.max(0.0, param.lower);
//                        param.uniformUpper = Math.min(timeScaleMaximum, param.upper);
//                        param.initial = initialRootHeight;
//                        break;
//                    case T50_SCALE:
//                        param.uniformLower = Math.max(0.0, param.lower);
//                        param.uniformUpper = Math.min(timeScaleMaximum, param.upper);
//                        param.initial = initialRootHeight / 5.0;
//                        break;
//                    case GROWTH_RATE_SCALE:
//                        param.uniformLower = Math.max(-growthRateMaximum, param.lower);
//                        param.uniformUpper = Math.min(growthRateMaximum, param.upper);
//                        break;
//                    case BIRTH_RATE_SCALE:
//                        param.uniformLower = Math.max(0.0, param.lower);
//                        param.uniformUpper = Math.min(birthRateMaximum, param.upper);
//                        break;
//                    case SUBSTITUTION_RATE_SCALE:
//                        param.uniformLower = Math.max(0.0, param.lower);
//                        param.uniformUpper = Math.min(substitutionRateMaximum, param.upper);
//                        param.initial = initialRate;
//                        break;
//                    case LOG_STDEV_SCALE:
//                        param.uniformLower = Math.max(0.0, param.lower);
//                        param.uniformUpper = Math.min(logStdevMaximum, param.upper);
//                        break;
//                    case SUBSTITUTION_PARAMETER_SCALE:
//                        param.uniformLower = Math.max(0.0, param.lower);
//                        param.uniformUpper = Math.min(substitutionParameterMaximum, param.upper);
//                        break;
//
//                    case UNITY_SCALE:
//                        param.uniformLower = 0.0;
//                        param.uniformUpper = 1.0;
//                        break;
//
//                    case ROOT_RATE_SCALE:
//                        param.initial = initialRate;
//                        param.gammaAlpha = 0.5;
//                        param.gammaBeta = param.initial / 0.5;
//                        break;
//
//                    case LOG_VAR_SCALE:
//                        param.initial = initialRate;
//                        param.gammaAlpha = 2.0;
//                        param.gammaBeta = param.initial / 2.0;
//                        break;
//
//                }
//                if (param.isNodeHeight) {
//                    param.lower = maximumTipHeight;
//                    param.uniformLower = maximumTipHeight;
//                    param.uniformUpper = timeScaleMaximum;
//                    param.initial = initialRootHeight;
//                }
//            }
//        }

//        dataReset = false;
        
        
    }

    /**
     * return a list of operators that are required
     *
     * @param ops the operator list
     */
    public void selectOperators(List<Operator> ops) {
        double initialRootHeight = 1;

//        if (options.clockModelOptions.getRateOptionClockModel() == FixRateType.FIX_MEAN) {
//            double rate = options.clockModelOptions.getMeanRelativeRate();
//
//            if (options.hasData()) {
//                initialRootHeight = meanDistance / rate;
//                initialRootHeight = round(initialRootHeight, 2);
//            }
//
//        } else {
//            if (maximumTipHeight > 0) {
//                initialRootHeight = maximumTipHeight * 10.0;
//            }
//        }
//
//        for (PartitionTreeModel tree : options.getPartitionTreeModels()) {
//            Operator op = tree.getOperator("subtreeSlide");
//            if (!op.tuningEdited) {
//                op.tuning = initialRootHeight / 10.0;
//            }
//        }
    }
    
    /////////////////////////////////////////////////////////////
    
    private double round(double value, int sf) {
        NumberFormatter formatter = new NumberFormatter(sf);
        try {
            return NumberFormat.getInstance().parse(formatter.format(value)).doubleValue();
        } catch (ParseException e) {
            return value;
        }
    }
    
	@Override
	public String getPrefix() {
		// TODO Auto-generated method stub
		return null;
	}


}
